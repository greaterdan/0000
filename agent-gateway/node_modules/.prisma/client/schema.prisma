// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

enum AccountKind {
  human
  agent
  treasury
}

enum AccountStatus {
  active
  suspended
  closed
}

enum JournalType {
  mint
  transfer
  adjust
  demurrage
}

enum JobStatus {
  submitted
  scored
  minted
  rejected
}

model Account {
  id              String        @id @default(uuid()) @db.Uuid
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz
  status          AccountStatus @default(active)
  kind            AccountKind
  displayName     String        @map("display_name")
  reputationScore Decimal       @default(0) @map("reputation_score") @db.Decimal(10, 2)
  tpmAttested     Boolean       @default(false) @map("tpm_attested")

  // Relations
  balances       Balance[]
  submittedJobs  Job[]          @relation("JobSubmitter")
  journalEntries JournalEntry[]

  @@map("accounts")
}

model Balance {
  accountId   String   @id @map("account_id") @db.Uuid
  microAmount Decimal  @default(0) @map("micro_amount") @db.Decimal(38, 0)
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@map("balances")
}

model JournalEntry {
  id           String      @id @default(uuid()) @db.Uuid
  ts           DateTime    @default(now()) @db.Timestamptz
  type         JournalType
  payload      Json
  prevHash     Bytes       @map("prev_hash")
  leafHash     Bytes       @map("leaf_hash")
  merkleRoot   Bytes       @map("merkle_root")
  sigDilithium Bytes       @map("sig_dilithium")
  sigSphincs   Bytes       @map("sig_sphincs")
  signerId     String      @map("signer_id")

  // Relations
  account Account @relation(fields: [signerId], references: [id])

  @@index([ts])
  @@index([type])
  @@index([merkleRoot])
  @@map("journal")
}

model Job {
  id                 String    @id @default(uuid()) @db.Uuid
  submitterAccountId String    @map("submitter_account_id") @db.Uuid
  spec               Json
  inputsHash         Bytes     @map("inputs_hash")
  attestation        Json?
  status             JobStatus @default(submitted)
  score              Float?
  verifierReport     Json?     @map("verifier_report")
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt          DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  submitterAccount Account @relation("JobSubmitter", fields: [submitterAccountId], references: [id])

  @@index([status])
  @@index([submitterAccountId])
  @@index([createdAt])
  @@map("jobs")
}

model Policy {
  id    String @id @default(uuid()) @db.Uuid
  key   String @unique
  value Json

  @@map("policy")
}

model Checkpoint {
  id             String   @id @default(uuid()) @db.Uuid
  periodStart    DateTime @map("period_start") @db.Timestamptz
  periodEnd      DateTime @map("period_end") @db.Timestamptz
  merkleRoot     Bytes    @map("merkle_root")
  witnessSigs    Json     @map("witness_sigs")
  objectStoreUri String   @map("object_store_uri")
  publishedAt    DateTime @default(now()) @map("published_at") @db.Timestamptz

  @@index([periodStart, periodEnd])
  @@map("checkpoints")
}

model Witness {
  id              String  @id @default(uuid()) @db.Uuid
  name            String  @unique
  pubkeyDilithium Bytes   @map("pubkey_dilithium")
  pubkeySphincs   Bytes   @map("pubkey_sphincs")
  active          Boolean @default(true)

  @@map("witnesses")
}

model Quote {
  id          String   @id @default(uuid()) @db.Uuid
  ts          DateTime @default(now()) @db.Timestamptz
  usdBid      Decimal  @map("usd_bid") @db.Decimal(10, 4)
  usdAsk      Decimal  @map("usd_ask") @db.Decimal(10, 4)
  basketQuote Json     @map("basket_quote")

  @@index([ts])
  @@map("quotes")
}

model Dispute {
  id                   String    @id @default(uuid()) @db.Uuid
  jobId                String    @map("job_id") @db.Uuid
  submitterAccountId   String    @map("submitter_account_id") @db.Uuid
  reason               String
  evidence             Json?
  status               String    @default("open")
  resolution           String?
  reVerificationResult Json?     @map("re_verification_result")
  createdAt            DateTime  @default(now()) @map("created_at") @db.Timestamptz
  resolvedAt           DateTime? @map("resolved_at") @db.Timestamptz

  @@index([jobId])
  @@index([submitterAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("disputes")
}

model OnrampIntent {
  id             String    @id @default(uuid()) @db.Uuid
  accountId      String    @map("account_id") @db.Uuid
  crypto         String
  amount         String
  aimAmount      String    @map("aim_amount")
  depositAddress String    @map("deposit_address")
  txHash         String?   @map("tx_hash")
  confirmations  Int?      @default(0)
  memo           String?
  status         String    @default("pending")
  expiresAt      DateTime  @map("expires_at") @db.Timestamptz
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz
  confirmedAt    DateTime? @map("confirmed_at") @db.Timestamptz
  completedAt    DateTime? @map("completed_at") @db.Timestamptz

  @@index([accountId])
  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("onramp_intents")
}
